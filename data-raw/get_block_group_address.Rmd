---
title: "Internet_Price"
output: html_document
---

NEED TO CLEAN THIS CODE!!!

# get residential mail addresses within state
```{r}
con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
md_locs <- st_read(con, query = "
                         SELECT a.*
                         FROM corelogic_usda.current_tax_200627_latest_all_add_vars_add_progs_geom_blk as a
                         WHERE a.geoid_cnty LIKE '24%'")
dbDisconnect(con)

data <- md_locs
data$property_indicator <- as.factor(data$property_indicator)

# Residential: 10 (Single Family Residence), 11 (Condominium), 21 (Duplex), 22 (Apartment)
# Considered 24 (Commercial Condominium) but cross-checking with land use code, county use code, and googling property addresses
# showed these were in fact all medical offices, business offices, etc. Excluding here.
data <- data %>% filter(property_indicator == 10 | # single family residence
                        property_indicator == 11 | # condo
                        property_indicator == 21 | # duplex
                        property_indicator == 22)  # apartment

data$geoid_bg <- substr(data$geoid_blk, 1, 12)
data$geoid_tr <- substr(data$geoid_blk, 1, 11)
md.data <- data[grepl(" MD ", data$mail_address),]
```

# get top 3 addresses near block group
```{r}
# md.data.2 <- md.data[!duplicated(md.data[, c('mail_address')]),]
md.data.2 <- md.data %>% distinct(mail_address, .keep_all = TRUE)

all.md.data <- matrix(, nrow = 0, ncol = 3)
# for(i in 1:dim(md.bg)[1])
# {
#   x <- st_distance(md.data, st_centroid(md.bg)[i,] %>% st_transform(st_crs(md.data)))
#   all.md.data <- rbind(all.md.data, st_drop_geometry(md.data[which(x %in% sort(x)[1:3]),]) %>%
#                          select(mail_address, property_centroid_latitude, property_centroid_longitude) %>%
#                          mutate(geoid_bg = md.bg[i,]$GEOID) %>% 
#                          sample_n(3))
# }

# write.csv(all.md.data, "md_three_address_in_block_group.csv")

all.md.data <- md.data.2 %>%
  group_by(geoid_bg) %>%
  sample_n(5, replace = T) %>%
  select(mail_address, property_centroid_latitude, property_centroid_longitude, geoid_bg)

x <- st_distance(all.md.data, st_centroid(md.bg) %>% st_transform(st_crs(all.md.data)))
all.md.data.2 <- as.data.frame(matrix(, nrow = 0, ncol = 3))
for (i in 1:(dim(x)[2]))
{
  all.md.data.2 <- rbind(all.md.data.2, st_drop_geometry(all.md.data[which(x[, i] %in% sort(x[, i])[1:3]),]) %>% 
    select(mail_address, property_centroid_latitude, property_centroid_longitude) %>%
    mutate(geoid_bg = md.bg[i,]$GEOID) %>%
    sample_n(3))
}

# APPROACH FOR MARYLAND - GET 5 ADDRESSES LISTED WITHIN EACH BLOCK GROUP, THEN find closest addresses to bg centroids within this group

# there are some repeats (again this is the closest address to that block group, so it will be roughly accurate - given that there isn't a lot of variability I genuinely don't think it will matter)
write.csv(all.md.data.2, "md_three_address_in_block_group.csv")
```


# I genuinely don't really know what I did below...
```{r}
# con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
# dc_dbWriteTable(con, "dc_working", "virginia_corelogic_residential", va.data)
# dbDisconnect(con)
```


```{r}
get_with_it <- st_within(va.data, va.tr.utm, sparse = FALSE)
va.data <- va.data %>% st_set_crs(st_crs(va.tr.utm))
all_data <- matrix(, nrow = 0, ncol = ncol(va.data) - 1)
idxs <- c()
dims <- c()
for (i in 1:nrow(va.tr.utm))
{
  if (dim(st_drop_geometry(va.data[which(get_with_it[,i]),]))[1] >= 5)
  {
    data <- st_drop_geometry(va.data[which(get_with_it[,i]),] %>% sample_n(5))
    dims <- c(dims, nrow(data))
    all_data <- rbind(all_data, data)
    idxs <- c(idxs, i)
  }
}
```


```{r}
write.csv(all_data, "address_sample_2_big.csv")
```


```{r}
get_with_it_bg1 <- st_within(va.data, va.bg.utm[1:1000,], sparse = FALSE)
# get_with_it_bg2 <- st_within(va.data, va.bg.utm[1001:2000,], sparse = FALSE)
# get_with_it_bg3 <- st_within(va.data, va.bg.utm[2001:3000,], sparse = FALSE)
# get_with_it_bg4 <- st_within(va.data, va.bg.utm[3001:4000,], sparse = FALSE)
# get_with_it_bg5 <- st_within(va.data, va.bg.utm[4001:5000,], sparse = FALSE)
# get_with_it_bg6 <- st_within(va.data, va.bg.utm[5001:nrow(va.bg.utm),], sparse = FALSE)
# get_with_it_bg <- cbind(get_with_it_bg1, get_with_it_bg2, get_with_it_bg3, get_with_it_bg4, get_with_it_bg5, get_with_it_bg6)
# get_with_it_bg <- st_within(va.data, va.bg.utm[1,], sparse = FALSE)
all_data_bg <- matrix(, nrow = 0, ncol = ncol(va.data) - 1)
idxs_bg <- c()
dims_bg <- c()
for (i in 1:nrow(va.bg.utm))
{
  if (dim(st_drop_geometry(va.data[which(get_with_it_bg[,i]),]))[1] >= 3)
  {
    data <- st_drop_geometry(va.data[which(get_with_it_bg[,i]),] %>% sample_n(3))
    dims_bg <- c(dims_bg, nrow(data))
    all_data_bg <- rbind(all_data_bg, data)
    idxs_bg <- c(idxs_bg, i)
  }
}

all_data_bg2 <- matrix(, nrow = 0, ncol = 1)
for (i in 1:nrow(va.bg.utm))
{
  if (dim(st_drop_geometry(va.data[which(get_with_it_bg[,i]),]))[1] >= 3)
  {
    data <- va.data[which(get_with_it_bg[,i]),] %>%
      sample_n(3) %>%
      select(geometry)
    all_data_bg2 <- c(all_data_bg2, data)
  }
}

pp <- read.csv("address_sample_3bg.csv")
point <- pp %>%
  select(property_centroid_longitude, property_centroid_latitude) %>%
  st_as_sf(coords = c("property_centroid_longitude", "property_centroid_latitude"), crs = 4326)

con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
dc_dbWriteTable(con, "dc_working", "va_bg_corelogic_3_points_per", point)
dbDisconnect(con)

point
```



# WHAT I PROBABLY WILL HAVE TO DO - GET LIKE 10 RANDOM POINTS WITHIN EACH BLOCK GROUP...i

```{sql connection=con}
SELECT a.*, b.*
INTO dc_working.va_bg_corelogic_2020_closest_address
FROM dc_working.va_bg_corelogic_3_points_per as a
CROSS JOIN LATERAL (
SELECT b.*, b.centroid <-> a.geometry AS dist
FROM dc_working.va_bg_acs_2019_centroid_coords_update AS b
ORDER by dist
LIMIT 1 ) AS b;
```


```{r}
demand3 <- demand2 %>% group_by(GEOID) %>% slice_min(which.min(dist))

dist <- st_distance(virginia_stores, ex)
dist2 <- unlist(apply(dist, 2, which.min))
print(head(dist2))
```


```{r}
con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
demand <- st_drop_geometry(st_read(con, query = "SELECT * FROM dc_common.block_group_centroids_closest_prop_vancwvpamdtn"))
dbDisconnect(con)

va_demand <- demand[substr(demand$geoid_bg, 1, 2) == "51",]
va_demand
```


```{r}
con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
closest_stores <- st_read(con, query = "SELECT * FROM dc_working.va_bg_corelogic_2020_closest_address2")
dbDisconnect(con)


closest_stores
```







```{r}

virginia_stores

# demand2 <- dbGetQuery(conn = con,statement = "
# SELECT subways.gid AS subway_gid,
#        subways.name AS subway,
#        streets.name AS street,
#        streets.gid AS street_gid,
#        streets.geom::geometry(MultiLinestring, 26918) AS street_geom,
#        streets.dist
# FROM nyc_subway_stations subways
# CROSS JOIN LATERAL (
#   SELECT streets.name, streets.geom, streets.gid, streets.geom <-> subways.geom AS dist
#   FROM nyc_streets AS streets
#   ORDER BY dist
#   LIMIT 1
# ) streets;")

con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
demand2 <- st_read(con, query = "SELECT a.*, b.*
FROM corelogic_usda.current_tax_200627_latest_all_add_vars_add_progs_geom_blk as a
CROSS JOIN LATERAL (
SELECT b.*, b.centroid <-> a.geometry AS dist
FROM dc_working.va_bg_acs_2019_centroid_coords_update AS b
ORDER BY dist
LIMIT 1
) as b
WHERE a.geoid_cnty LIKE '51%';")
dbDisconnect(con)

ex <- va.bg %>% st_centroid(geometry) %>% rename(centroid = geometry) %>% select(GEOID, NAME)
ex <- st_transform(ex, crs = "+proj=longlat +datum=WGS84")
ex$x <- st_coordinates(ex$centroid)[, 1]
ex$y <- st_coordinates(ex$centroid)[, 2]

con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
dc_dbWriteTable(con, "dc_working", "va_co_acs_2019_centroid_coords_update", ex)
dbDisconnect(con)

```


```{r}
con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
a <- st_drop_geometry(st_read(con, query = "SELECT * FROM dc_working.va_bg_corelogic_2020_closest_address3"))
dbDisconnect(con)

head(a, 10)

b <- a %>%
  select(mail_address, property_centroid_latitude, property_centroid_longitude, geoid_blk)

write.csv(b, "three_address_in_block_group.csv")
# con <- get_db_conn(db_pass = "rsu8zvrsu8zv")
# dc_dbWriteTable(con, "dc_working", "va_co_acs_2019_centroid_coords_update", b)
# dbDisconnect(con)
```









